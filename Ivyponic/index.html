<!DOCTYPE html>
<html lang="en">

<head>
    <title>Vinay Bhamidipati</title>
    <link rel="stylesheet" href="index.css">
    <!--
        <link rel='apple-touch-icon' href='assets/professional_pic.jpg'>
        <link rel="icon" href="assets/favicon.ico" type="image/ico" sizes="16x16" />
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    -->
</head>

<body>
    <header>
        <nav id="nav-bar" class="nav-bar">
            <div class="nav-logo">
                <img class="logo" alt="head shot" src="../assets/professional_pic.jpg" />
                <a href="../index.html">
                    <h1>Vinay Bhamidipati</h1>
                </a>
            </div>

            <div class="nav-links">
                <ul>
                    <li>
                        <a class="nav-links-item" href="#intro">Introduction</a> <!-- hero -> intro-->
                    </li>
                    <li>
                        <a class="nav-links-item" href="#design">Design</a> <!--projects -> operating -->
                    </li>
                    <li>
                        <a class="nav-links-item" href="#testing">Testing</a> <!--projects -> operating -->
                    </li>
                    <!--
                    <li>
                        <a class="nav-links-item" href="#gallery">Gallery</a>                      
                    </li>

                    
                    --->
                    
                    <li>
                        <a class="nav-links-item" href="../index.html#projects">Projects</a>
                    </li>
                </ul>
            </div>

            <div class="nav-menu">
                <img id="nav-icon" src="../assets/hamburger.svg" alt="Menu Icon" class="hamburger-icon" />
            </div>
        </nav>
    </header>

    <main>
        <section id="intro">
            <div class="hero-text" data-aos="fade-up">
                <!-- <p class="greet-text">Hi there! I am</p>-->
                <p class="text-gradient name-text">Ivyponic</p>
                <p class="job-text"> A Smart Gardening Solution</p>
                <p class="intro-text">
        
                    Ivyponic is a sealed, hydroponic indoor gardening solution that can automatically grow a plant under customizable conditions, 
                    including airflow, lighting, temperature, humidity, and nutrient density. 
                    <br><br>
                    Ivyponic grows plants without the need to micromanage 
                    or take care of the plants directly. It uses the PiTFT screen to allow for customization of these conditions to optimize for a 
                    specific plant’s needs. Ivyponic contains a hydroponic growing system, using a pump to deliver fertilized water to plants, without 
                    the need of soil. The on-board Raspberry Pi manages all variables for plant growth to maintain user-defined targets. 
                    Ivyponic gathers the necessary environmental data using PPM, temperature, and humidity sensors. 
                     
                </p>
                <!--<a href="#contact" class="contact-button">Contact Me</a>-->
                
            </div>
            <div class="hero-image" data-aos="fade-up">
                <img class="hero-image" src="assets/box_sexy.png" width="512" alt="Hero Image" />
            </div>
        </section>

   
        <section id="design">
            <h2 class="text-gradient" data-aos="fade-up">Design</h2>
            <div class="gallery_row">
                <div class="gallery_column">
                    <img src="assets/d_inital.jpg">
                </div>
                <div class="gallery_column">
                  <img src="assets/d_final.jpg">   
                </div>
            </div>
            <p> 
                During the ideation phase of Ivyponic, 
                we envisioned the system as depicted in the leftmost drawing above. The Raspberry Pi and PiTFT would be mounted at the bottom of the enclosure, 
                displaying temperature, humidity, airflow, and lighting parameters. Above the Raspberry Pi, there would be a catch pan that would route 
                excess drip back into the water pump. The water reservoir would be located at the top of the enclosure, and the pump would have two 
                valve-controlled spray heads–one for misting the enclosure and another for watering the plants. The system would be complete with humidity, 
                temperature, and airflow sensors. However, after realizing our pump could not activate the misters, we had to pivot to the drip-irrigation 
                system as shown on the right. 
                <br><br>
                One constant in our design process was the chassis. Because we wanted to design a visually distinct and appealing home garden product, 
                we used clear acrylic. This allowed the plant and lighting to be a focal point of the aesthetics, while also allowing users to see the behind-the-scenes 
                of the device; the electronics, wiring, and pump system were fully visible. To construct the chassis, we measured and laser-cut acrylic panels, using 
                Gorilla epoxy to glue them together. 
            </p>

            <div class="gallery_row">
                <div class="gallery_column">
                    <img src="assets/status.png">
                    <img src="assets/lighting.png">
                </div>
                <div class="gallery_column">
                    <img src="assets/targets.png">   
                    <img src="assets/presets.png">   
                </div>
            </div>
            
            <p>
                Another key point of design was the user interface on the PiTFT. 
                At the top of each menu is a taskbar that displays the currently active menu. 
                Additionally, there are forward, backward, and power icons that illustrate the functions of the adjacent buttons. 
                The “Status” menu displays the current status of the enclosure including the current humidity, temperature, PPM, fan speed, and RGB values. 
                These values are retrieved from the various sensors, the fan, and the LED light strip, respectively. 
                The next screen allows the user to adjust the user-controlled targets to their desired values. For example, if the user wanted to maintain a 
                temperature of 25 degrees celsius in the enclosure, he or she could set that from this menu. Next, the “Lighting” menu allows the user to 
                toggle the lights on and off for the various hours in the day. Finally, the “Presets" menu allows the user to select from hard-coded presets. 
                Each preset contains the optimal values for temperature, humidity, PPM, and RGB for a specific plant. Upon selecting one of these presets, 
                these optimal values are loaded into the system, and the enclosure attempts to maintain them.
            </p>

            <div class="gallery_row">
                <div class="gallery_column">
                    <img src="assets/targets_select.jpg">
                </div>
                <div class="gallery_column">
                    <img src="assets/lighting_select.jpg">   
                </div>
                <div class="gallery_column">
                    <img src="assets/presets_select.jpg">   
                </div>
            </div>

            <p>
                In our original plans for Ivyponic, the display would be touchscreen, 
                which influenced how we envisioned user interaction. However, upon implementing the menu interfaces, 
                we discovered that our PiTFT touchscreen was dysfunctional, reporting random values for touch positions. Because of this, 
                we had to redesign the display, coming up with a UI design that did not require touch. Eventually, we settled 
                on the above system where each screen has a select button that displays a nested menu with new button functions. 
                These functions change based on the current menu. In the case of the first menu, the select menu was 
                unnecessary because the menu does not allow for editing values. In the subsequent menus—targets, lighting, and 
                presets—a select button was necessary. The select button switches the current tab to a "selection mode" (depicted above) where the side button 
                functionality changes to allow for users to customize values. Upon entering the select menu, the TFT buttons cycle through parameters or 
                toggle or increment values. In the place of a power button, a back button was added to return to the menu to "viewing mode".
            </p>


        </section>



        <section id="testing">
            <h2 class="text-gradient" data-aos="fade-up">Testing and Challenges</h2>
            <div>
                <p>
                    To simplify testing and adhere to good coding practices, each module was segregated into its own file. 
                    First, we tested each component within its respective 
                    file under the <i>if __name__ == ‘__main__’:</i> line. Then, if it functioned correctly, we instantiated its object in the main file. Since the 
                    pump and the fan were driven from the motor controller, we instantiated them both as Motor objects and tested them within the motor.py file.
                    <br><br>
                    This method allowed us to narrow down whether a problem was caused by the individual component 
                    or rather the main code operation. A specific problem we faced was that the fan and pump were not functioning properly in the main code. Because we had 
                    already tested them in motor.py, we knew it had to be a problem in main.py. We discovered that, because we were instantiating the fan and pump on new threads, 
                    a thread would eventually not have GPIO.BCM set which would cause the program to crash. We fixed this problem by modifying the main code to spawn a single thread 
                    each for the fan and pump.
                    <br><br>

                    Before running code, we first tested our hardware with benchtop EE tools including 
                    power supplies and an oscilloscope. We determined that there were no hardware problems with the pump and fan we chose to use. 
                    Furthermore, we identified GPIO pins on our Raspberry Pi that were dysfunctional.
                    <br><br>

                    A fundamental challenge we faced was that the maximum pressure our pump could generate was insufficient to activate 
                    the misters we planned to use in our original design. This forced us to pivot to a drip-irrigation system that did not require sprayers. We initially
                    considered using a stronger pump that could activate the sprayers, but we decided against this due to time and budget constraints.
                    <br><br>

                    The integration of many sensors, motors, and lights on one Raspberry Pi also posed a challenge. Each of these devices required GPIO pins, but some of the GPIO pins 
                    were fried, so wiring them up was complex. First, the PiTFT itself uses many of the GPIO pins and the SPI0 channel. To enable additional SPI channels, we edited 
                    /boot/config.txt, but strange PiTFT behavior meant that certain channels could not be used. Sometimes, rebooting an indefinite number of times was required to 
                    eventually enable some of the SPI channels. Furthermore, the NeoPixel light strips required specific GPIO pins, forcing us to shift around many of the GPIO pins
                    until all devices, specifcially the PPM sensor (SPI) and temperature/humidity sensor (I2C), ran correctly. After demoing with the temperature sensor, the I2C 
                    connection became unstable, and running i2cdetect revealed that the connection was flickering, with Linux constantly detecting and losing connection to the AHT20.
                </p>
         
            </div>
        </section>

        <!--
        <section id="gallery">
            <h2 class="text-gradient" data-aos="fade-up">Gallery</h2>
            <div class="gallery_row">
                <div class="gallery_column">
                    <img src="assets/door1.jpg">
                </div>

                <div class="gallery_column">
                  <img src="assets/door2.jpg">   
                </div>
    
                <div class="gallery_column">
                    <img src="assets/unlocked.jpg">
                </div>
        
              </div>
        </section>
        -->

      
    </main>

    <footer>
        <p>The End!</p>
        <p>Developed by Vinay Bhamidipati</p>
    </footer>
    
    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
    <script>       
        AOS.init({
            once: true,
            delay: 0
        });
    </script>

</body>

<script src="../index.js""></script>

</html>